<%@ page import="gov.fnal.elab.*" %>
<%@ page import="gov.fnal.elab.datacatalog.*" %>
<%@ page import="gov.fnal.elab.datacatalog.query.*" %>
<%@ page import="gov.fnal.elab.cosmic.*" %>
<%@ page import="gov.fnal.elab.cosmic.beans.*" %>
<%@ page import="java.util.*" %>

<%-- Edited to address XSS flaws - JG 22Mar2018 --%>
<%-- Reflecting user-input variables like "filename", "id", and "jd"
		 to the screen in error messages can be an XSS vulnerability.
		 For ElabJspException errors, though, I fixed
		 common/src/jsp/include/errorpage.jsp to sanitize them. If that
		 fails, I've left cleaned versions of the messages as comments. --%>
<%
	Geometries geometries = null;
	request.setAttribute("geometries", geometries);
	String id = request.getParameter("detectorID");
	String jd = request.getParameter("jd");
	String action = request.getParameter("action");
	// In practice, filename will be of the form 6148.2018.0101.0 - JG 22Mar2018
	String filename = request.getParameter("filename");
	GeoEntryBean geoEntry = null;
	
	if (filename != null) {
		/* I assume this gets data about the input file from the database.  Tracking
		 *   it down terminates at org.griphyn.vdl.dbschema.Annotation, which
		 *	 we don't have source code for - JG 22Mar2018 */
		CatalogEntry entry = elab.getDataCatalogProvider().getEntry(filename);
		if (entry == null) {
	    	throw new ElabJspException("No metadata about " + filename + " found.");
				//throw new ElabJspException("No metadata found for that filename.");
		}
		request.setAttribute("e", entry);
		//[m] grr 
		/* Based on the above comment, I guess Mihael didn't like setting the data as
		 *   a request Attribute?  It does seem like there should be a more
		 *   appropriate way - JG 22Mar2018 */

		if (entry.getTupleValue("julianstartdate") == null) {
			throw new ElabJspException(filename + " is missing the Julian start date");
			//throw new ElabJspException("File is missing the Julian start date");
		}
		id = (String) entry.getTupleValue("detectorid");
		if (id == null) {
			throw new ElabJspException("No detector associated with " + filename);
			//throw new ElabJspException("No detector associated with that file.");
		}
		jd = entry.getTupleValue("julianstartdate").toString();
		geometries = new Geometries(elab, Integer.parseInt(id));
	}
	else {
		geometries = new Geometries(elab, user);
	}
	if (id != null && jd != null) {
		Geometry g = geometries.getGeometry(Integer.parseInt(id));
		if (g == null) {
			throw new ElabJspException("No geometry information found for detector " + id + " on date " + jd);
			//throw new ElabJspException("No geometry information found for the requested detector on the given date.");
		}
		if (filename == null) {
			geoEntry = g.getGeoEntry(jd);
		}
		else {
			//so, we're looking for the last entry before the date of the file
			//but there's some weirdness. Perhaps in the case of julian dates
			//lexicongraphic order is the same as temporal order
			//It certainly seems like Geometry.java thinks that way
			SortedMap geos = g.getGeoEntriesBefore(jd);
			if (geos.isEmpty()) {
				throw new ElabJspException("Error: no geometry information for detector " + id + " for when this data was taken.");
				//throw new ElabJspException("Error: no geometry information exists for the requsted detector for when this data was taken.");
				}
			geoEntry = (GeoEntryBean) geos.get(geos.lastKey()); 
		}
	}
	if (geoEntry == null) {
		geoEntry = new GeoEntryBean();
		request.setAttribute("geometryNotFound", Boolean.TRUE);
	}

	if (action != null) {
		if (action.equals("saveas")) {
			GeoEntryBean newGeoEntry = new GeoEntryBean(geoEntry);
			geoEntry = newGeoEntry;
		}
	} 
    int year = Calendar.getInstance().get(Calendar.YEAR);
    request.setAttribute("selectYear", year); 	
	request.setAttribute("action", action);
	request.setAttribute("geoEntry", geoEntry);
%>
