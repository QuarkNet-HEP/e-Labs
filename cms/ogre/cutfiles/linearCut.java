// Import the window toolkit & graphics stuff
import java.awt.*;
import java.awt.Image.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.awt.image.*;

// import the applet class
import java.applet.*;

// These classes are for Url's.
import java.net.*;

public class linearCut extends Applet implements ActionListener,MouseMotionListener,MouseListener {

    // The canvas to display
    Image canvas;

    //... gotten from the applet parameters
    String file;
    int    width;
    int    height;

    // The applet base URL
    URL base;

    // The X-coordinate and Y-coordinate ofthe last Mouse Position.
    int xpos;
    int ypos;
    int cut1X = 0;
    int cut1Y;
    int cut2X = 0;
    int cut2Y;
    int button = 0;

    int X0,Y0;                  // Pixel offset of the image in the box
    int Xmin, Xmax, Ymin, Ymax; // Pixel locations of the min/max of the plot
    float graphXmin, graphXmax; // Values of the min/max in plot units (GeV?)
    float pixel2X, pixel2Xk;    // Conversion constants for plot units -> pixels

    // wll be true when the Mouse is in theRectangle
    boolean rect1Active;
    boolean cut1, cut2;
    boolean dragging;

    // Simple textbox to show the numbers and allow simple cut definitions
    TextField cuts = new TextField(20);

    // The stuff to put into the textbox
    public String cutmin, cutmax;


    // Flush all the global stuff on unload
    public void stop() {
    }


    // Read in the parameters placed in the html file that we'll be needing later
    public void start() {

	// Get the parameters of the image to load
	file    = getParameter("file");
	URL url = null;
	try {
	    url = new URL(base + "/" + String.valueOf(file));
	}catch (MalformedURLException e) {}

	// Size of the graphic
	width     = Integer.parseInt(getParameter("width"));
        height    = Integer.parseInt(getParameter("height"));

	// Xmin/Xmax of the graph in plot units
	graphXmin = Float.parseFloat(getParameter("xmin"));
	graphXmax = Float.parseFloat(getParameter("xmax"));

	// Xmin/Xmax of the graph in pixels
	Xmin      = Integer.parseInt(getParameter("pmin"));
	Xmax      = Integer.parseInt(getParameter("pmax"));

	// Ymin/Ymax of the graph in pixels
	Ymin = Y0 + (int)(0.105*height);
	Ymax = Y0 + (int)(0.892*height);

	// Pixel-to-X conversion parameters
	pixel2X  = Float.parseFloat(getParameter("X2px"));
	pixel2Xk = Float.parseFloat(getParameter("Xcst"));

	// load the image
	canvas = getImage(url);
	canvas.getWidth(this);
	canvas.flush();

	X0    = 0;
	Y0    = 0;

	cut1X = (int)graphXmin;
	cut2X = (int)graphXmax;

	cutmin = new String(String.valueOf(cut1X));
	cutmax = new String(String.valueOf(cut2X));

	// Update the text box with the cuts
	cuts.setText(" Select events in [" + cutmin + "," + cutmax + "]");

	// And notify the calling page
	update_calling_page();

	Xmin += X0;
	Xmax += X0;

	repaint();
	return;
    }

    // Initialize the applet
    public void init() {

	// The try-catch is necassary when the URL isn't valid
	// Of course this one is valid, since it is generated by
	// Java itself.
	try {
	    // getDocumentbase gets the applet path.
	    base = getCodeBase();
	}
	catch (Exception e) {}

	// We'll redraw the applet each time the mouse has moved.
	// Add the MouseMotionListener to the applet
	addMouseListener(this);
	addMouseMotionListener(this);
	
	// Use the Flow layout manager
	setLayout(new FlowLayout());

	// Put up the text box, and bind it over to the actionlistener
	add(cuts);
        cuts.addActionListener(this);
    }

    public int round(double X) {
	double remainder = X = (int)X;
	if ( remainder < 0.50 )
	    return (int)X;
	else
	    return (int)X + 1;
    }

    /*-- Convert pixel values to plot values --*/
    private int pixel2plot(float pixel) {
      return round(0.993*(pixel2Xk + pixel2X*(pixel - X0)));
    }

    /*-- And backwards from plot to pixel --*/
    private int plot2pixel(int plot) {
      return X0 + (int)((1.0067*plot - pixel2Xk)/pixel2X);
    }

    public void paint(Graphics g) {
	// composite the graphics for rendering 
	compositeGraph(g);
    }

     public void compositeGraph( Graphics g ) {

	int plotX = pixel2plot(xpos);
	
	// Draw a shaded rectangle voiding out areas that aren';t selected
	super.paint( g );
	Graphics2D g2 = (Graphics2D) g;

	Dimension d = getSize();
	int w = d.width;
	int h = d.height;

        // Creates the buffered image with 33% opacity.
        BufferedImage buffImg = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
        Graphics2D gbi = buffImg.createGraphics();
	AlphaComposite ac = AlphaComposite.getInstance(getRule(5),0.5f);

	// Put up the canvas
	gbi.drawImage(canvas,X0,Y0,width-X0,height-Y0,this);

	// Draw a line to indicate the current cut position
	if (rect1Active) { 
	    gbi.setColor(Color.red);
	    gbi.drawLine( xpos, Ymin,  xpos, Ymax);

	    if ( xpos < X0 + width/2 ) {
		gbi.drawString(String.valueOf(plotX) + "GeV", xpos+5, ypos);
	    } else {
		gbi.drawString(String.valueOf(plotX) + " GeV", xpos-60, ypos);
	    }
	}

	if ( cut1 ) {
	  gbi.setColor(Color.gray);
	  gbi.setComposite(ac);
	  gbi.fillRect((int)Xmin, Ymin, (int)(cut1X-Xmin), Ymax-Ymin);
	}

	if ( cut2 ) {
	  gbi.setColor(Color.gray);
	  gbi.setComposite(ac);
	  gbi.fillRect(cut2X, Ymin, (int)(Xmax-cut2X)+1, Ymax-Ymin);
	}

	if ( cut1 && cut2 ) {
	  gbi.setColor(Color.yellow);
	  gbi.setComposite(ac);
	  gbi.fillRect(cut1X, Ymin, cut2X-cut1X, Ymax-Ymin);
	}

	if ( cut1 && dragging ) {
	  gbi.setColor(Color.yellow);
	  gbi.setComposite(ac);
	  gbi.fillRect(cut1X, Ymin, xpos-cut1X, Ymax-Ymin);
	}

	g2.drawImage(buffImg, null, 0, 0);
     }

     public void update(Graphics g) {
	 paint(g);
     }

    // Gets the requested compositing rule.
    public int getRule(int rule){
        int alphaComp = 0;
        switch ( rule ) {
        case 0: alphaComp = AlphaComposite.SRC; break;
        case 1: alphaComp = AlphaComposite.DST_IN; break;
        case 2: alphaComp = AlphaComposite.DST_OUT; break;
        case 3: alphaComp = AlphaComposite.DST_OVER; break;
        case 4: alphaComp = AlphaComposite.SRC_IN; break;
        case 5: alphaComp = AlphaComposite.SRC_OVER; break;
        case 6: alphaComp = AlphaComposite.SRC_OUT; break;
        case 7: alphaComp = AlphaComposite.CLEAR; break;
        }
        return alphaComp;
    }

     public void setCuts(int button) {

	// Check if the click was inside the rectangle area.
	if (button == 1 && rect1Active) {
	    cut1 = true;
	    // Save the coordinates of the click
	    cut1X = xpos;
	} else if (button == 3 && rect1Active) {
	    cut2 = true;
	    // Save the coordinates of the click
	    cut2X = xpos;
	} else {
	    cut1 = false;
	    cut2 = false;
	    cut1X = 0;
	    cut2X = 0;
	}

	// Handle some special cases that seem confusing
	if ( cut1X > cut2X ) {
	    int temp = cut1X;
	    cut1X = cut2X;
	    cut2X = temp;
	} else if ( cut1X == cut2X && button == 1 ) {
	    cut2X = Xmax + 1;
	} else if (cut1X == cut2X && button == 3 ) {
	    cut1X = Xmin - 1;
	}

	// if new cuts were made.... update things accordingly
	if (cut1) {
	    int cut1Xvalue = pixel2plot(cut1X);
	    cutmin = String.valueOf(cut1Xvalue);
	} else {
	    cutmin = String.valueOf(round(graphXmin));
	}
	if (cut2) {
	    int cut2Xvalue = pixel2plot(cut2X);
	    cutmax = String.valueOf(cut2Xvalue);
	} else {
	    cutmax = String.valueOf(round(graphXmax));
	}

	// Update the text box containing the cuts
	cuts.setText(" Select events in [" + cutmin + "," + cutmax + "]");

	// And update the page containing the applet
	update_calling_page();

	return;
     }

    // This will be excuted whenever the mouse moves in the applet
    public void mouseMoved(MouseEvent me) { 
	xpos = me.getX();
	ypos = me.getY();

	// Check if the mouse is in the rectangle
	if ( xpos >= Xmin-1 && xpos <= Xmax+1 && ypos >= Ymin && ypos <= Ymax )
	    rect1Active = true;
	else 
	    rect1Active = false;

	//show the results of the motion
	repaint();
    }

    // This is works like mouseMoved but only when the mouse is being pressed
    // at the same time. To use this for drawing rectangles like in Paint programs
    // you will have to use mousePressed to remember the first coordinates.
    public void mouseDragged(MouseEvent me) {
	xpos = me.getX();
	ypos = me.getY();

	// Check if the mouse is in the rectangle
	if ( xpos >= Xmin-1 && xpos <= Xmax+1 && ypos >= Ymin && ypos <= Ymax )
	    rect1Active = true;
	else 
	    rect1Active = false;

	//show the results of the motion
	repaint();
    }

    // This method will be called when the mouse has been clicked.
    public void mouseClicked (MouseEvent me) {

	cut1 = true;
	cut2 = true;
	setCuts(me.getButton());

	if ( me.getButton() == 1 )
	  cut2X = round(Xmax+1.0f);
	else
	  cut1X = round(Xmin-1.0f);

	repaint();
    }


    // This is called when the mouse has been pressed
    public void mousePressed (MouseEvent me) {

	if ( me.getButton() != 1 )
	  return;

	dragging = true;
	cut1 = true;
	cut2 = false;

	// Set the value of the low cut since we're dragging
	setCuts(1);

	//show the results of the click
	repaint();
    }

    // When it has been released
    // not that a click also calls these Mouse-Pressed and Released.
    // since they are empty nothing hapens here.
    public void mouseReleased (MouseEvent me) {

      if ( me.getButton() != 1 )
        return;

      dragging = false;

      // Set the value of the high cut since we're dragging
      setCuts(3);

      //show the results of the click
      repaint();
    }

    // This is executed when the mouse enters the applet. it will only
    // be executed again when the mouse has left and then re-entered.
    public void mouseEntered (MouseEvent me) {
    }

    // When the Mouse leaves the applet.
    public void mouseExited (MouseEvent me) {
    }  

    public int getMin() {
	return Integer.parseInt(cutmin);
    }

    public int getMax() {
	return Integer.parseInt(cutmax);
    }


    // Handle cuts entered directly in the test box
    public void actionPerformed(ActionEvent event) {

      if (event.getSource() != cuts) return;
      String s = cuts.getText();

      // Take apart the string and set the new cuts
      String range = s.substring(s.indexOf("[")+1, s.indexOf("]"));

      // Take the cut values apart & make sure they're valid
      if ( !isNumeric(range) ) {
	cuts.setText(s);
	cut1 = false;
	cut2 = false;
	cut1X = (int)Xmin;
	cut2X = (int)Xmax;
      } else {
	cut1 = true;
	cut2 = true;

	int temp = Integer.parseInt(range.substring(0,range.indexOf(",")));
	cut1X = plot2pixel(temp);

	temp = Integer.parseInt(range.substring(range.indexOf(",")+1,range.length()));
	cut2X = plot2pixel(temp);
      }

      // update the display to reflect the entered values
      repaint();

      // And update the page containing the applet
      update_calling_page();
      
    }

    // Since we can't count on LiveConnect being there
    // we can't really do a simple JS call to get the 
    // values of the cuts... this updates the page through
    // a hidden iFrame... sad... and silly... but there it is
    public void update_calling_page() {
	/* Try sending the information up the line */
	try {
	    URL encUrl =  new java.net.URL(
			    base,
			    "j2js.html?"+
			    java.net.URLEncoder.encode(
			      cuts.getText(), "UTF-8"
						       )
					   );
	    System.out.println(encUrl);
	    getAppletContext().showDocument(encUrl, "j2js");
	    
	} catch (Exception ex) {;}

	return;
    }

    // check for valid numeric strings in the cut boxes
    public boolean isNumeric(String srcString) {
      String strValidChars = "0123456789.,-+";
      char strChar;
      boolean blnResult = true;
      int i = 0;

      if (srcString.length() == 0) return false;

      // compare srcString to list of valid characters
      for (i = 0; i < srcString.length() && blnResult == true; i++) {
        strChar = srcString.charAt(i);
        if (strValidChars.indexOf(strChar) == -1) {
          blnResult = false;
        }
      }
      return blnResult;
    }

} // End of public class linearCut
